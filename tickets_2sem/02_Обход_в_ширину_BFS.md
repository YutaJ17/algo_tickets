## 2. Обход в ширину (BFS)

### Идея

**BFS(Breadth-First_Search)** - это алгоритм обхода/поиска по графу, который исследует все вершины на текущем уровне глубины перед переходом к вершинам следующего уровня.

### Принцип работы
1. Начинаем с начальной вершины, помещаем ее в очередь
2. Отмечаем вершину как посещенную
3. Пока очедедь не пуста:
    1. Извлекаем вершину из очереди
    2. Обрабатываем ее
    3. Добавляем все непосещенные соседние вершины в очередь
    4. Отмечаем их как посещенные

### Структура данных
Использует _очередь_(FIFO).

### Сложность
`V` - количество вершин, `E` - количество ребер
- Временная: `O(V + E)`(список смежности) или `O(V^2)`(матрица смежности)
- Пространственная: `O(V)` для хранения посещенных вершин (доп память, без учета хранения графа)


### Применение
- Поиск кратчайшего пути в невзвешанном графе
- Проверка связности графа
- Поиск компонент связности
- Топологическая сортировка
- Поиск циклов

### Реализация на C++

#### BFS через список смежности
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <list>

class Graph {
    int V;
    std::vector<std::list<int>> adj;  

public: 
    Graph(int V): V(V) {
        adj.resize(V);
    }

    void addEdge(int v1, int v2) {
        adj[v1].push_back(v2);
    }

    void BFS(int start) {
        std::vector<bool> visited(V, false);
        visited[start] = true;
        std::queue<int> q;    // единственное различие от итеративного DFS, здесь очередь, а не стек
        q.push(start);
        std::cout << "BFS from " << start << ":" << std::endl;
        while (!q.empty()) {
            int v = q.front();
            std::cout << v << " ";
            q.pop();
            for (int neighbor : adj[v]) {
                if (!visited[neighbor]) {
                    q.push(neighbor);
                    visited[neighbor] = true;
                }
            }
        }
    std::cout << std::endl;
    }
};

```

#### Алгоритмы на BFS (в последствии добавится реализация и пояснения по использованию)

|№|Название|Расшифровка|Пояснение|
|---|---|---|---|
|1|**Multi-source BFS**|BFS от нескольких источников|Добавляем все стартовые вершины в очередь одновременно. Находим расстояния до ближайшего из источников. Задачи: гниющие апельсины, распространение огня|
|2|**0-1 BFS**|BFS для весов 0 и 1|Используем `deque` вместо `queue`: рёбра веса 0 → в начало, веса 1 → в конец. Сложность O(V+E) вместо O(E log V) у Dijkstra|
|3|**Bidirectional BFS**|Двунаправленный поиск|Запускаем BFS одновременно от start и end. Встречаются посередине. Сложность O(b^(d/2)) вместо O(b^d). Для поиска кратчайшего пути между двумя вершинами|
|4|**Level-order BFS**|BFS с явными уровнями|Обрабатываем граф послойно, зная номер уровня каждой вершины. Используем `levelSize = q.size()` для обхода текущего уровня целиком|
|5|**BFS для кратчайшего пути**|Shortest Path in Unweighted Graph|Классическое применение BFS - находит кратчайший путь в невзвешенном графе. Первое посещение вершины = кратчайший путь к ней|
|6|**BFS на неявном графе**|State Space BFS|Генерируем состояния "на лету" без явного построения графа. Для головоломок (Sliding Puzzle, замки), игр, переходов между состояниями|
|7|**Алгоритм Кана**|Kahn's Algorithm (Topological Sort)|Топологическая сортировка через BFS. Обрабатываем вершины с нулевой входящей степенью, "удаляем" рёбра. Если обработаны не все вершины → есть цикл|
|8|**BFS для проверки двудольности**|Bipartite Check via BFS|Раскрашиваем граф в 2 цвета послойно: соседи текущего уровня красим в противоположный цвет. Конфликт цветов → граф не двудольный|
|9|**BFS для поиска цикла минимальной длины**|Shortest Cycle Detection|Для каждого ребра (u,v) запускаем BFS от v до u без использования этого ребра. Минимальная длина цикла = min(dist[v→u] + 1)|
|10|**BFS с препятствиями**|BFS with Obstacles|BFS на матрице/графе, где можно "пройти сквозь" k препятствий. Состояние: (x, y, obstacles_used). Размерность visited увеличивается|
|11|**BFS с ограничениями**|Constrained BFS|BFS с дополнительными условиями: макс. число шагов, временные ограничения, запрещённые состояния на определённых этапах|
|12|**BFS для компонент связности**|Connected Components via BFS|Запускаем BFS для каждой непосещённой вершины, считаем количество запусков = количество компонент. Альтернатива DFS/Union-Find|
|13|**BFS на матрице (Flood Fill)**|Matrix BFS|BFS для обхода связных областей в 2D/3D матрице. 4 или 8 направлений. Базовый алгоритм для островов, заливки, лабиринтов|
|14|__A_ Search_*|A-star Algorithm|BFS с эвристикой: используем priority_queue вместо queue. f(n) = g(n) + h(n), где h - эвристическая оценка. При h=0 превращается в Dijkstra|
|15|**Dijkstra Algorithm**|Алгоритм Дейкстры|BFS с приоритетной очередью для взвешенных графов с неотрицательными весами. Всегда извлекаем вершину с минимальным расстоянием|
|16|**BFS для построения дерева кратчайших путей**|Shortest Path Tree|BFS строит дерево, где путь от корня до любой вершины - кратчайший. Сохраняем parent[] для восстановления путей|
|17|**BFS с весами на уровнях**|Weighted Level BFS|Все рёбра на одном уровне имеют одинаковый вес. Специальный случай между 0-1 BFS и Dijkstra|
|18|**Parallel BFS**|Параллельный BFS|BFS с параллельной обработкой уровней. Все вершины текущего уровня обрабатываются одновременно. Для больших графов на GPU/многопоточность|