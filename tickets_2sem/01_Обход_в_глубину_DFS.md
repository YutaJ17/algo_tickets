## 1. Обход в глубину (DFS)

### Идея

**DFS(Depth-First-Search)** - это алгоритм обхода/поиска по графу, исследующий его как можно глубже, прежде чем вернуться назад.

### Принцип работы
1. Начинаем с исходной вершины
2. Посещаем ее и помещаем как посещенную
3. Рекурсивно посещаем все непосещенные смежные вершины
4. Когда тупик - возвращаемся назад

### Структура данных
- _Рекурсивный подход_ использует стек вызовов.
- _Итеративный подход_ явно использует стек.

### Сложность
- Временная: `O(V + E)`, где `V` - количество вершин, `E` - количество ребер
- Пространственная: `O(V)` для хранения посещенных вершин (доп память, без учета хранения графа)

### Применение
- Поиск пути между двумя вершинами
- Проверка связности графа
- Поиск циклов в графе
- Топологическая сортировка
- Поиск компонентов связности
- Решение головоломок (лабиринты, судоку)
- Обход деревьев (preorder, inorder, postorder)

### Реализация на C++

#### Рекурсивный DFS для графа (список смежности)

```cpp
#include <iostream>
#include <vector>
#include <list>

class Graph {
    int V; // количество вершин
    std::vector<std::list<int>> adj; // список смежности
    
    // вспомогательная рекурсивная функция
    void DFSUtil(int v, std::vector<bool>& visited) {
        // помечаем вершину как посещенную
        visited[v] = true;
        std::cout << v << " ";

        // вызываем для смежных вершин
        for (int neighbor : adj[v]) {
            if (!visited[neighbor]) {
                DFSUtil(neighbor, visited);
            }
        }
    } 

public:
    Graph(int V): V(V) {
        adj.resize(V);
    }

    // функция добавления ребра
    void addEdge(int v, int w) {
        adj[v].push_back(w);
        adj[w].push_back(v);  // unordered graph
    }

    // DFS обход, начиная с вершины v
    void DFS(int start) {
        std::vector<bool> visited(V, false);
        DFSUtil(start, visited);
    }

    // DFS для несвязного графа (обход всех компонент)
    void DFSComplete() {
        std::vector<bool> visited(V, false);

        for (int v = 0; v < V; v++) {
            if (!visited[v]) {
                DFSUtil(v, visited);
            }
        }
    }
};

int main() {
    Graph g(6);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 4);
    g.addEdge(3, 5);

    std::cout << "рекурсивный DFS обход, начиная с вершины 0: ";
    g.DFS(0);

    std::cout << std::endl;
}
```

#### Итеративный DFS для графа (список смежности + стек)

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>

class Graph {
    int V;
    std::vector<std::list<int>> adj;

public:
    Graph(int V): V(V) {
        adj.resize(V);
    }

    void addEdge(int v, int w) {
        adj[v].push_back(w);
    }

    void DFS_iterative(int start) {
        std::vector<bool> visited(V, false);
        std::stack<int> s;

        s.push(start);

        while (!s.empty()) {
            int v = s.top();
            s.pop();

            if (!visited[v]) {
                std::cout << v << " ";
                visited[v] = true;
            }

            for (int neighbor : adj[v]) {
                if (!visited[neighbor]) {
                    s.push(neighbor);
                }
            }
        }
    }
};

int main() {
    Graph g(6);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 4);
    g.addEdge(3, 5);

    std::cout << "итеративный DFS, начиная с вершины 0: ";
    g.DFS_iterative(0);
}
```

#### Алгоритмы на DFS (в последствии добавится реализация и пояснения по использованию)


|№|Название|Расшифровка|Пояснение|
|---|---|---|---|
|1|**DFS с Backtracking**|Поиск с возвратом|Пробуем вариант → если не подходит, откатываемся назад. Используется для перебора всех решений (N-Queens, Sudoku, перестановки)|
|2|**DFS с 3 цветами (White-Gray-Black)**|Трёхцветный обход|WHITE=непосещённая, GRAY=в процессе, BLACK=обработана. Для поиска циклов в орграфах и классификации рёбер|
|3|**DFS с временными метками**|DFS с in-time/out-time|Фиксируем время входа и выхода из вершины. Позволяет определять отношения "предок-потомок" и классифицировать рёбра|
|4|**Топологическая сортировка (DFS)**|Topological Sort via DFS|Упорядочиваем вершины DAG так, чтобы для каждого ребра u→v вершина u шла раньше v. Добавляем вершину в результат ПОСЛЕ обхода всех потомков|
|5|**Алгоритм Косарайю**|Kosaraju's Algorithm (SCC)|Поиск сильно связных компонент за 2 прохода DFS: 1) обычный DFS, 2) DFS на транспонированном графе в порядке убывания времени выхода|
|6|**Алгоритм Тарьяна (SCC)**|Tarjan's SCC Algorithm|Поиск сильно связных компонент за 1 проход DFS. Использует стек и массивы low/disc для отслеживания достижимости|
|7|**Алгоритм Тарьяна (мосты)**|Tarjan's Bridge Algorithm|Поиск мостов (критических рёбер). Мост - ребро, удаление которого увеличивает число компонент связности. Использует low[v] > disc[u]|
|8|**Поиск точек сочленения**|Articulation Points (Cut Vertices)|Находит критические вершины - их удаление разъединяет граф. Использует условия: корень с ≥2 детьми ИЛИ low[v] ≥ disc[u]|
|9|**Двусвязные компоненты**|Biconnected Components|Находит максимальные подграфы без точек сочленения. Каждое ребро принадлежит ровно одной двусвязной компоненте|
|10|**DFS с мемоизацией**|DFS + Memoization|Кэшируем результаты DFS для подзадач, чтобы не пересчитывать. Превращает экспоненциальную сложность в полиномиальную (DP на графах)|
|11|**Iterative Deepening DFS (IDDFS)**|Итеративное углубление|Запускаем DFS с ограничением глубины 1, 2, 3... Комбинирует преимущества BFS (оптимальность) и DFS (память)|
|12|**DFS с отсечениями (Pruning)**|Branch and Bound DFS|Отсекаем бесперспективные ветви поиска на основе эвристик или границ. Используется в оптимизационных задачах|
|13|**Алгоритм Флёри**|Fleury's Algorithm (Eulerian)|Поиск Эйлерова пути/цикла (проходим каждое ребро ровно 1 раз). DFS с правилом: не идём по мосту, если есть альтернатива|
|14|**Алгоритм Hierholzer**|Hierholzer's Algorithm|Более эффективный алгоритм для Эйлерова цикла. DFS + стек для построения цикла "наизнанку"|
|15|**2-SAT через DFS**|2-Satisfiability|Проверка выполнимости булевой формулы в 2-КНФ. Строим импликационный граф, ищем SCC. Решение есть ⟺ x и ¬x в разных SCC|
|16|**Проверка двудольности**|Bipartite Graph Check|Пытаемся раскрасить граф в 2 цвета так, чтобы соседи были разных цветов. DFS с чередованием цветов|
|17|**Flood Fill DFS**|Заливка области|DFS на матрице для обхода связанной области. Базовый алгоритм для задач типа "острова", заливки, поиска областей|
|18|**DFS для транзитивного замыкания**|Transitive Closure via DFS|Для каждой вершины запускаем DFS и отмечаем все достижимые вершины. Строим матрицу достижимости|
|19|**Pre/In/Post-order обходы дерева**|Tree Traversals|Три классических способа обхода: Pre (корень→левый→правый), In (левый→корень→пр��вый), Post (левый→правый→корень)|
|20|**LCA через DFS**|Lowest Common Ancestor|Поиск ближайшего общего предка двух вершин в дереве. DFS для построения массивов parent/depth, затем подъём|
|21|**DFS для построения Spanning Tree**|Остовное дерево|DFS естественным образом строит остовное дерево - древесные рёбра формируют дерево, покрывающее все вершины связного графа|
|22|**Классификация рёбер**|Edge Classification|Делит рёбра на 4 типа: Tree (древесные), Back (обратные→цикл), Forward (прямые), Cross (поперечные). Основано на временных метках|
|23|**DFS для поиска цикла минимальной длины**|Shortest Cycle via DFS|В невзвешенном графе: для каждого ребра (u,v) ищем кратчайший путь от v до u без этого ребра. Min(dist[v→u] + 1)|

