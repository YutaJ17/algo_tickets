## 3. Топологическая сортировка

### Идея
**Топологическая сортировка** - алгоритм упорядочивания вершин _ориентированного ациклического графа (DAG)_ в линейный порядок, при котором для каждого ребра `(u, v)` вершина `u` находится перед вершиной `v`. 

### Принцип работы
Существуют 2 основных подхода: алгоритм Кана(на основе удаления ребер) и алгоритм на основе DFS:
1. Алгоритм Кана
    a. Находим все вершины с нулевой входящей степенью
    b. Помещаем их в очередь
    c. Пока очередь не пуста:
        I. Извлекаем вершину и добавляем ее в результат сортировки
        II. Удаляем все исходящие из нее ребра 
        III. Если у соседней вершины входящая степень стала нулевой - добавляем ее в очередь

2. Алгоритм на основе DFS
    a. Запускаем DFS из каждой непосещенной вершины
    b. После обработки всех соседей добавляем вершину в стек. 
    с. Извлекаем вершины из стека - это и будет топологическим порядком.

### Структура данных
1. Алгоритм Кана: очередь (или стек) для обработки вершин, массив для хранения входящих степеней.
2. Алгоритм на DFS: стек (явный или рекурсивный), массив посещенных вершин.

### Сложность 

### Сложность (оба алгоритма)
`V` - количество вершин, `E` - количество ребер
- Временная: `O(V + E)`(список смежности) 
- Пространственная: `O(V)` для дополнительных структур

### Важные условия
- Граф должен быть ориентированным
- Граф должен быть ацикличным (не содержать циклов) (_Directed Acyclic Graph_)
- Для одного графа могут существовать несколько вариантов топологичекой сортировки

### Применение
- Системы сборки проектов (CMake, Maven, Gradle) - определение порядка компиляции
- Планирование задач (Task Scheduling) с зависимостями
- Разрещение зависимостей пакетов в менеджерах пакетов (pip, apt, npm)
- Анализ потоковых данных в компиляторах
- Gantt диаграммы

### Реализация на C++ 

#### Алгоритм Кана (Kahn`s algorithm)
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <queue>

class Graph {
    int V;
    std::vector<std::list<int>> adj;
public:
    Graph(int V): V(V) {
        adj.resize(V);
    }

    void addEdge(int v1, int v2) {
        adj[v1].push_back(v2);
    }

    std::vector<int> topologicalSortKahn() {
        std::vector<int> indegree(V, 0);  // массив входящий степеней
        std::vector<int> result;    // результат сортировки

        // подсчет входящих степеней
        for (int u = 0; u < V; u++) {
            for (int v : adj[u]) {
                indegree[v]++;
            }
        }
        
        std::queue<int> q;  // очередь для вершин с нулевой входящей степенью
        for (int i = 0; i < V; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }

        int cnt = 0;  // счетчик обработанных вершин
        while (!q.empty()) {
            int u  = q.front();
            q.pop();
            result.push_back(u);
            cnt++;
            for (int neighbor : adj[u]) {
                indegree[neighbor]--;
                if (indegree[neighbor] == 0) {
                    q.push(neighbor);
                }
            }
        }
        if (cnt != V) {
            std::cerr << "Error: graph is not acyclic" << std::endl;
            return std::vector<int>();
        }

        return result;
    }
};

int main() {
    Graph g(8);
    g.addEdge(7, 5);
    g.addEdge(7, 6);
    g.addEdge(5, 4);
    g.addEdge(6, 4);
    g.addEdge(5, 2);
    g.addEdge(2, 1);
    g.addEdge(6, 3);
    g.addEdge(3, 1);
    g.addEdge(1, 0);
    g.addEdge(0, 7);

    std::vector<int> res = g.topologicalSortKahn();
    for (int v : res) {
        std::cout << v << " ";
    }
}
```

