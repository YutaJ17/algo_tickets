## 4. Конденсация графа, поиск компонент слабой, сильной связности

### Теория
**Конденсация графа** - это процесс преобразования исходного ориентированного графа в ациклический ориентированный граф (DAG), где каждая вершина соответствует компоненте _сильной связности_ (SCC) исходного графа.

Ориентированный граф считается **сильно связным**, если он состоит из одной компоненты сильной связности.
**Компонента сильной связности** - максимальный по включению сильно связный подграф.

Ориентированный граф считается **слабо связным**, если при замене всех его дуг на ребра, мы получим _связный_ неориентированный граф (он состоит из одной компоненты слабой связности).
**Компонента слабой связности** - максимальный по включению слабо связный подграф. 

### Принцип работы

#### Поиск компонент слабой связности
Делается тривиально через `DFS`: 
- Храним массив принадлежности вершин к компонентам слабой связности, где индекс - номер вершины, а значение - номер компоненты. Держим счетчик слабых компонент, который будем прибавлять к соответствующим ячейкам массива.
- После прохода увеличиваем счеичик компонент, пройденные вершины помечаем в массиве принадлежности. 
- Делаем такие проходы, пока не обойдем все вершины.


#### Поиск компонент сильной связности
Существуют 2 алгоритма нахождения компонент сильной связности: Косарайю (Kosaraju) и Тарьяна (Tarjan). Косарайю работает немного дольше из-за двух проходов `DFS` по графу, также тратит больше памяти для хранения транспонированного графа, но в реализации и понимании он кратно проще алгоритма Тарьяна.

##### Алгоритм Косарайю
Граф и его транспонированная версия имеют одни и те же `SCC`.
1. Запускаем `DFS` на исходном графе, добавляем вершины в `stack` во время посещения.
2. Обрабатываем вершины в порядке выхода из `stack`: если вершина на втором проходе не посещена, то запускаем   `DFS` от нее (как от стартовой), но на транспонированном графе.
3. Вершины, полученные на во время прохода `DFS` образуют одну из компонент связности. Продолжаем, пока `stack` не опустеет.

##### Алгоритм Тарьяна
//to do

### Структура данных
Стек рекурсии для `DFS`, стек для записи работы `DFS`, массивы для хранения компонент

### Сложность (для всех перечисленных алгоритмов выше)
`V` - количество вершин, `E` - количество ребер
- Временная: `O(V + E)`(список смежности) 
- Пространственная: `O(V)` для дополнительных структур

### Реализация на C++

#### Поиск компонент слабой связности

```cpp
class Graph {
    int V;
    std::vector<std::vector<int>> adj;

public:
    Graph(int V): V(V) {
        adj.resize(V);
    }
    
    void addEdge(int v1, int v2) {
        adj[v1].push_back(v2);
        adj[v2].push_back(v1);
    }
    
    std::vector<int> dfs(int start, std::vector<bool>& visited) {
        std::vector<int> result;
        std::stack<int> stack;
        stack.push(start);
        
        while (!stack.empty()) {
            int v = stack.top();
            stack.pop();

            if (!visited[v]) {
                result.push_back(v);
                visited[v] = true;
            }

            for (int neighbor : adj[v]) {
                if (!visited[neighbor]) {
                    stack.push(neighbor);
                }
            }
        }
        return result;
    }
    
    std::vector<int> weak_comp() {
        std::vector<int> weak_comp(V, 0);
        std::vector<bool> visited(V, false);
        std::vector<int> temp_res;
        int comp_number = 0;
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                temp_res = dfs(i, visited);
                comp_number++;
                for (int i : temp_res) {
                    weak_comp[i] = comp_number;
                }
            }
        }
        return weak_comp;
    }
};
```
#### Поиск компонент сильной связности
### Алгоритм Косарайю

```cpp
#include <iostream>
#include <vector>
#include <stack>

class Graph {
    int V;
    std::vector<std::vector<int>> adj;
    std::vector<std::vector<int>> adj_rev;
    
    void DFS_util(int start, std::stack<int>& result_stack, std::vector<bool>& visited, std::vector<std::vector<int>>& adj) {
        visited[start] = true;
        for (int neighbor : adj[start]) {
            if (!visited[neighbor]) {
                DFS_util(neighbor, result_stack, visited, adj);
            }
        }
        result_stack.push(start);
    }

public:
    Graph(int V): V(V) {
        adj.resize(V);
        adj_rev.resize(V);
    }

    void addEdge(int v1, int v2) {
        adj[v1].push_back(v2);
        adj_rev[v2].push_back(v1);
    }

    std::stack<int> DFS() {
        std::stack<int> result_stack;
        std::vector<bool> visited(V, false);
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                DFS_util(i, result_stack, visited, adj);
            }
        }
        return result_stack;
    }

    std::vector<std::vector<int>> kosaraju_alg() {
        std::stack<int> stack = DFS();
        std::vector<std::vector<int>> strong_comp;
        std::vector<bool> visited(V, false);
        
        while (!stack.empty()) {
            int v = stack.top();
            stack.pop();
            if (!visited[v]) {
                std::stack<int> temp_stack;
                DFS_util(v, temp_stack, visited, adj_rev);
                std::vector<int> component;
                while (!temp_stack.empty()) {
                    int v1 = temp_stack.top();
                    temp_stack.pop();
                    component.push_back(v1);
                }
                strong_comp.push_back(component);
            }
        }
    return strong_comp;
    }

};

int main() {
    int V, E;
    std::cin >> V >> E;
    Graph g(V);

    for (int i = 0; i < E; i++) {
        int v1, v2;
        std::cin >> v1 >> v2;
        g.addEdge(v1 - 1, v2 - 1);
    }

    std::vector<std::vector<int>> data = g.kosaraju_alg();

    std::cout << "---------------" << std::endl;
    std::cout << "strong comp:" << std::endl;
    for (std::vector<int> i : data) {
        for (int j : i) {
            std::cout << j + 1 << " ";
        }
        std::cout << std::endl;
    }
}
```

#### Алгоритм Тарьяна
//to do