## 5. Поиск и восстановление всех видов циклов

### Теория 
**Замкнутый путь** - путь, у которого начало и конец совпадают.
**Цепь** - путь без повторяющихся ребер.
**Простая цепь** - путь без повторяющихся вершин.
**Цикл** - замкнутая цепь.
**Эйлеров путь** - путь, проходящий через все ребра графа по 1 разу.
**Гамильтонов путь** - путь, проходящий через все вершины графа по 1 разу.

Виды циклов:
- **Простой цикл** - замкнутая простая цепь, то есть замкнутый путь без повторяющийся вершин (n>=3).
- **Эйлеров цикл** - замкнутый Эйлеров путь.
- **Гамильтонов цикл** - замкнутый Гамильтонов путь.
//to be contin

### Реализация на C++

#### DFS с тремя цветами
Алгоритм ищет все циклы в неориентированном графе (необязательно связном). Можно модифицировать алгоритм для работы в орграфе, убрав проверку на `parent`.

```cpp
class Graph {
    int V;
    std::vector<std::vector> adj;
    enum Color {
        White,
        Gray,
        Black
    };

    void find_cycles(int v,         // текущая вершина
                    int parent,         // родительская вершина (откуда пришли)  
                    std::vector<Color>& color,      // массив цветов вершин
                    std::vector<int>& path,         // текущий путь обхода (серые вершины)
                    std::vector<std::vector<int>>& all_cycles)          // найденные циклы
    {
        color[v] = Gray;        // вершина в процессе обработки
        path.push_back(v);    // path хранит последовательность вершин от начала обхода до текущей

        // просматриваем всех соседей текущей вершины
        for (int neighbor : adj[v]) {
            if (neighbor == parent) {
                continue;           // две симм. дуги за цикл не считаем
            }

            if (color[neighbor] == White) {  // сосед не был посещен
                find_cycles(int neighbor, v, color, path, all_cycles); // продолжаем обход
            }

            else if (color[neighbor] == Gray) {  // найден цикл (вершина уже была посещена)
                std::vector<int> cycle;

                // находим в path позицию, с которой цикл начался
                auto it = std::find(path.begin(), path.end(), neighbor);
                for (; it < path.end(); it++) {
                    cycle.push_back(*it);
                }
                all_cycles.push_back(cycle);  // сохраняем цикл
            }
        }
        color[v] = Black; // завершаем обработку вершины
        path.pop_back();
    }

public:
    std::vector<std::vector<int>> list_cycles() {
        std::vector<std::vector<int>> all_cycles;
        std::vector<Color> color(V, White);
        std::vector<int> path;

        for (int i = 0; i < V; i++) {
            if (color[i] == White) {
                // parent = -1 означает, что у стартовой вершины нет родителя
                find_cycles(i, -1, color, path, all_cycles);
            }
        }
        return all_cycles;
    }

};
```

Сложность алгоритма:
`V` - количество вершин, `E` - количество ребер, `C` - количество циклов.
Временная: `O(V * (V + E) + V * C)`
Пространственная: `V + E + V * C`