# Мастер-теорема

Мастер-теорема (Master Theorem) используется для анализа сложности рекурсивных алгоритмов, особенно тех, которые решают задачи с помощью рекурсии, разделяя их на подзадачи одинакового типа (принцип _разделяй и влавствуй_).

Мастер-теорема применима к рекуррентным соотношениям следующего вида:

```math
T(n)= aT\left(\frac{n}{b}\right) + f(n) 
```


где:


| Параметр | Интерпретация                                            |
| -------- | -------------------------------------------------------- |
| a≥1      | количество подзадач, на которые делится исходная задача; |
| b>1      | во сколько раз уменьшается размер каждой подзадачи;      |
| f(n)     | трудоёмкость разбиения и слияния (нерекурсивная часть).  |


### Идея применения

Алгоритм решает задачу из трёх шагов:

1. Делит задачу на `a` подзадач размера `n/b`;
    
2. Рекурсивно решает каждую из них;
    
3. Объединяет результаты за время `f(n)`.
    

Цель — сравнить, что растёт быстрее:

- **рекурсивная часть** aT(n/b),

- или **вспомогательная работа** f(n).
    
От этого зависит итоговая асимптотика T(n).


### Формулировка мастер-теоремы
Пусть $T(n)$ задаётся как выше. Определим $n^{\log_b a}$ — количество листьев в дереве рекурсии. Тогда асимптотика $T(n)$ определяется сравнением $f(n)$ с этой функцией.

#### Случай 1: Работа в листьях доминирует
Если $f(n) = O(n^{\log_b a - \varepsilon})$ для некоторого $\varepsilon > 0$ (т.е. $f(n)$ растёт полиномиально медленнее, чем $n^{\log_b a}$), то:

```math
T(n) = \Theta(n^{\log_b a})
```

#### Случай 2: Работа распределена равномерно по уровням
Если $f(n) = \Theta(n^{\log_b a} \log^k n)$ для некоторого $k \geq 0$ (т.е. $f(n)$ и $n^{\log_b a}$ имеют одинаковую скорость роста с логарифмическим множителем), то:

```math
T(n) = \Theta(n^{\log_b a} \log^{k+1} n)
```

#### Случай 3: Работа в корне доминирует
Если $f(n) = \Omega(n^{\log_b a + \varepsilon})$ для некоторого $\varepsilon > 0$ (т.е. $f(n)$ растёт полиномиально быстрее, чем $n^{\log_b a}$), и выполняется условие регулярности $a f(n/b) \leq c f(n)$ для некоторой константы $c < 1$ и всех достаточно больших $n$, то:

```math
T(n) = \Theta(f(n))
```

### Анализ сложности Merge Sort
#### Рекуррентное соотношение

Для Merge Sort рекуррентное соотношение имеет вид:

```math
T(n) = 2T\left(\frac{n}{2}\right) + \Theta(n)
```

- T(n) — время сортировки массива из n элементов

- 2T(n/2) — два рекурсивных вызова для половин массива

- Θ(n) — время слияния двух отсортированных половин

#### Применение мастер-теоремы
##### Шаг 1: Определяем параметры

Сравниваем с общей формулой:

```math
T(n) = aT\left(\frac{n}{b}\right) + f(n)
```

Получаем:

- a = 2 (делим на 2 подзадачи)

- b = 2 (размер каждой подзадачи n/2)

- f(n) = Θ(n) (время слияния)

##### Шаг 2: Вычисляем $n^{\log_b a}$

```math
n^{\log_b a} = n^{\log_2 2} = n^1 = n
```

##### Шаг 3: Сравниваем $f(n)$ и $n^{\log_b a}$

Имеем:

- f(n) = Θ(n)

- $n^{log_b a}$ = n

- Получаем: f(n) = $Θ(n^{log_b a})$

##### Шаг 4: Определяем случай мастер-теоремы

Это Случай 2 с k = 0, поскольку:

f(n) имеет ту же скорость роста, что и $n^{log_b a}$

Формально: f(n) = $Θ(n^{log_b a} log^0 n)$

##### Шаг 5: Применяем формулу для Случая 2

```math
T(n) = Θ(n^{\log_b a} \log^{k+1} n)
```

Подставляем наши значения:

- $log_b a$ = $log_2 2$ = 1

- k = 0

Получаем:

```math
T(n) = Θ(n^1 \log^{0+1} n) = Θ(n \log n)
```

#### Пояснение

В формуле $T(n) = aT(n/b) + f(n)$:

$a$ — во сколько раз увеличивается количество подзадач

$b$ — во сколько раз уменьшается размер каждой подзадачи

Откуда берётся $n^{\log_b a}$?

Интерпретация как количество листьев:

Глубина рекурсии: $\log_b n$ (пока $n$ не станет 1)

На последнем уровне: $a^{\text{глубина}} = a^{\log_b n}$ подзадач размера 1

По формуле смены основания: $a^{\log_b n} = n^{\log_b a}$

Интерпретация через общую работу в листьях:

Если бы нерекурсивная работа $f(n)$ равнялась 0, то $T(n)$ было бы равно общему количеству операций в листьях, которое оценивается как $O(n^{\log_b a})$.

Таким образом, $n^{\log_b a}$ характеризует асимптотический рост работы, сосредоточенной на нижнем уровне рекурсии (в листьях).

Сравнение $f(n)$ и $n^{\log_b a}$ отвечает на вопрос:

Что вносит основной вклад в сложность — работа по разбиению и слиянию f(n) на верхних уровнях или работа по решению самых мелких подзадач ($n^{\log_b a}$) на нижнем уровне?