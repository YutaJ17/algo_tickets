## 16. Построение пирамиды O(n)  

### Построение пирамиды (build_heap)

Чтобы из неупорядоченного массива построить кучу, выполняется **просеивание вниз (heapify_down)**, начиная с последнего родителя:

```cpp
void heapify_down(int* arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify_down(arr, n, largest);
    }
}

void build_heap(int* arr, int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify_down(arr, n, i);
    }
}
```


### Почему сложность O(n), а не O(n log n)

На первый взгляд кажется, что раз `heapify_down` — O(log n), а вызывается он для `n/2` элементов,  
то должно быть `O(n log n)`.  
Но это **ошибочно**, потому что не каждый узел просеивается на всю глубину.

### Математический вывод: почему построение пирамиды — **O(n)**

### Структура дерева

Пирамида — это **полное бинарное дерево**.  
Высота дерева:
```
h = ⌊log₂ n⌋
```

Уровни считаем **от низа вверх**:

- уровень `0` — листья,
    
- уровень `1` — родители листьев,
    
- …
    
- уровень `h` — корень.

### Сколько узлов на уровне `k`

На нижнем уровне (`k = 0`) примерно половина всех узлов — это листья.  
Чем выше уровень, тем меньше узлов —  
каждый уровень содержит вдвое меньше узлов, чем предыдущий.

Примерно:

```
число узлов на уровне k ≈ n / 2^(k + 1)
```

### Сколько работы делает каждый узел

Операция `heapify_down(i)` (просеивание вниз)  
может затронуть максимум `k` уровней, если узел находится на уровне `k` (от низа).

Поэтому стоимость одной операции на уровне `k`: `≈ O(k)`

### Суммируем вклад всех уровней

Общая трудоёмкость:

`T(n) = сумма (число узлов на уровне) × (стоимость heapify_down)`


$$
T(n) = \sum_{k=0}^{h} \frac{n}{2^{k+1}} \cdot O(k)
$$

Здесь:

- n — размер массива  
- n / 2^(k+1) — количество элементов на уровне k-й глубины (каждый уровень содержит вдвое меньше элементов, чем предыдущий)  
- O(k) — стоимость операции "просеивание вниз" на уровне k

---

### 1. Раскрытие \( O(k) \)

Асимптотическая нотация \( O(k) \) означает, что существует некоторая константа \( c \), такая что для всех \( k \):

```math
\text{внутренняя\_операция}(k) \le c \cdot k
```

Заменим *O(k)* на его эквивалент в виде константы *c*:

$$
T(n) = \sum_{k=0}^{h} \frac{n}{2^{k+1}} \cdot c \cdot k
$$

---

### 2. Вынесение \( n \) и \( c \) из суммы

Заметим, что переменная \( n \) не зависит от суммы по \( k \), так что можно вынести её за знак суммы. То же самое касается и константы \( c \):

$$
T(n) = c \cdot n \sum_{k=0}^{h} \frac{k}{2^{k+1}}
$$

---

### 3. Сумма по \( k \)

Теперь, нам нужно проанализировать саму сумму. Сумма по \( k \):

$$
\sum_{k=0}^{h} \frac{k}{2^{k+1}}
$$

является конечной и сходящейся (она имеет предел, когда \( h \to \infty \)). Мы можем оценить её как константу. Для этого используем результат из анализа числовых рядов, где сумма этой серии сходится к некоторой константе (например, 2):

$$
\sum_{k=0}^{\infty} \frac{k}{2^{k+1}} = 2
$$

---

### 4. Применение оценки для суммы

Теперь, используя сходство суммы с постоянной константой, мы можем оценить её значимость:

$$
T(n) = c \cdot n \cdot O(1)
$$

Где \( O(1) \) — это наша константа, определённая из суммы по \( k \).

---

### 5. Упрощение

Теперь, упрощаем выражение, и так как \( c \) — это константа, можем её снова включить в большую нотацию \( O \):

$$
T(n) = O(n)
$$

---

### Итоговый вывод

Итак, конечный результат:

$$
T(n) = O(n)
$$

Где мы получили асимптотику \( O(n) \), так как произведение \( n \) на константу из суммы даёт линейное время работы.
